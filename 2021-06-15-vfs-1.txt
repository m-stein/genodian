                  Genodes VFS #1: Basic configuration

Over the last years the Virtual File System (VFS) has played an ever more
important role in Genode-based systems. Its applications cover not only access
to conventional file systems but also font servers, network stacks,
cryptographic devices, debugging facilities, and more. Yet documentation about
the VFS is quite scattered and context-specific. In this article series I'd
like to gather simple examples that explain how to use most plugins and
utilities around Genodes Virtual File System (VFS).

Populating a local VFS with static content
------------------------------------------

Let's start with a very basic example that demonstrates some fundamental
aspects of the Genode VFS. Unlike with most unix-based systems, file systems in
Genode are component-local. That means, each program that uses the VFS has its
own root directory that spans its very individual structure of directories and
files. In order to equip an application with its own VFS and root directory,
two things are needed: First, I'll have to link the VFS library against my
program by adding it to the 'target.mk' file:

! TARGET  := my_program
! SRC_CC  := main.cc
! LIBS    += base vfs

With that, I can trigger the creation of the VFS environment in this program by
adding the '<vfs>' node to the programs configuration:

! <start name="my_program">
!   <resource name="RAM" quantum="1M"/>
!   <config>
!     <vfs/>
!   </config>
! </start>

Note that, at first sight, this doesn't change much for the application though.
If I'm using the native Genode runtime (the 'base' library), I'm still in that
runtime, if libc or POSIX, I'm still in LibC or POSIX. The only difference is,
that the VFS root directory is now accessible in addition to my common runtime.

In order to demonstrate this, let's replace my imaginary program with the
FS-query tool ('repos/gems/src/app/fs_query'). The FS-query tool is a small
native Genode component that can report the content of directories and files of
its local VFS. Please have a look at example 1 on my branch now. In this
scenario, FS query is told to report the contents of the local root directory:

! <config>
!   <vfs/>
!   <query path="/"/>
! </config>

Running the scenario, the FS-query report confirms that the directory is
available and empty:

! <dir path="/"/>

Now, let's say I merely want to add a static text file to this directory. This
is addressed by the <inline> file system (example 2):

! <config>
!   <vfs>
!     <inline name="x">Some file content!</inline>
!   </vfs>
!   <query path="/" content="yes" size="yes"/>
! </config>

I set the file name through the 'name' attribute and, inside the node, I
specified the static content of the file. You may have noticed that I also
changed the query command. With the 'content' and 'size' attributes set, FS
query will not only list files found at the requested path but also try to
print their content and size. Consequently, the output of example 2 looks as
follows:

! <dir path="/">
!   <file name="x">Some file content!</file>
! </dir>

Next, I want to add a sub-directory by using the <dir> file system:

! <vfs>
!   <inline name="x">Some file content!</inline>
!   <dir name="y"/>
! </vfs>

Running the scenario again, I can see my new directory listed:

! <dir path="/">
!   <dir name="y"/>
!   <file name="x" size="18">Some file content!</file>
! </dir>

Change also the query path to '/y', FS query reports that 'y' is still empty:

! <dir path="/y"/>

I can combine <inline> and <dir> file systems to create an individual static
file system for my component (example 3):

! <vfs>
!   <inline name="README">Mail me for the README!</inline>
!   <inline name="VERSION">2.16</inline>
!   <dir name="config">
!     <inline name="verbose">yes</inline>
!     <dir name="tcp_ports"/>
!     <dir name="udp_ports">
!       <inline name="69"><forward to="10.0.0.1"/></inline>
!     </dir>
!     <inline name="dns_servers"/>
!   </dir>
! </vfs>

And, as also demonstrated by example 3, I can set a list of multiple query
commands for FS query and they will be concatenated into a single report:

! <dir path="/">
!   <dir name="config"/>
!   <file name="README" size="23">Mail me for the README!</file>
!   <file name="VERSION" size="4">2.16</file>
! </dir>
! <dir path="/config">
!   <dir name="tcp_ports"/>
!   <dir name="udp_ports"/>
!   <file name="dns_servers" size="0"/>
!   <file name="verbose" size="3">yes</file>
! </dir>
! <dir path="/config/udp_ports">
!   <file name="69" size="24" xml="yes"><forward to="10.0.0.1"/></file>
! </dir>

Accessing a VFS from the libc runtime
-------------------------------------

Although you can access a VFS also from Genodes native runtime, I'd like to
start with the libc runtime. I think that for developers accustomed to
unix-based systems this is the easier way to get their hands on the topic and
it's valuable knowledge anyway considering the importance of ported software
for Genode.

In example



The '<ram/>' node mounts a VFS plugin, named RAM file system
('repos/os/src/lib/vfs/ram_file_system') at the point where it is added.
Directories and files created at this plugin are stored in the programs RAM and
disappear as soon as the program exits, like with tmpfs in unix-based systems.

